# -*- coding: utf-8 -*-
G = nx.read_graphml("Ecoli_TRN.graphml")
G_operon = nx.read_graphml("Ecoli_operon_TRN.graphml")

# Imports
import networkx as nx
from typing import List, Tuple, Set
from itertools import combinations
import numpy as np
from collections import Counter

"""##1.2.1. Feed-Forward Loop (FFL) Motif Detection"""

def find_ffl_motifs(G: nx.DiGraph) -> List[Tuple[str, str, str]]:
    """
    Detect feed-forward loops (FFLs) in the directed graph given as input.

    Parameters
    ----------
    - param: G : Networkx digraph
        Graph to analyze
    - return: list
        List of detected motifs, each represented as a tuple (X, Y, Z).
    """
    # ------- IMPLEMENT HERE THE BODY OF THE FUNCTION ------- #
    motifs = []

    for X in G.nodes:
        successors_X = set(G.successors(X))
        for Y in successors_X:
            successors_Y = set(G.successors(Y))
            # Intersection of X's and Y's targets gives Z
            common_targets = successors_X & successors_Y
            for Z in common_targets:
                if Z != X and Z != Y and X != Y:
                    motifs.append((X, Y, Z))

    return motifs
    # ----------------- END OF FUNCTION --------------------- #

"""##1.2.2. Bi-fan Motif Detection"""

def find_bf_motifs(G: nx.DiGraph) -> List[Tuple[str, str, str, str]]:
    """
    Detect bi-fan (BF) motifs in the directed graph given as input.

    Parameters
    ----------
    - param: G : Networkx digraph
        Graph to analyze
    - return: list
        List of detected motifs, each represented as a tuple (X, Y, Z).
    """
    # ------- IMPLEMENT HERE THE BODY OF THE FUNCTION ------- #
    motifs = []
    nodes = list(G.nodes)

    for i, Z in enumerate(nodes):
        for j in range(i + 1, len(nodes)):
            W = nodes[j]
            preds_Z = set(G.predecessors(Z))
            preds_W = set(G.predecessors(W))
            shared_preds = preds_Z & preds_W
            if len(shared_preds) >= 2:
                for X, Y in combinations(shared_preds, 2):
                    if len({X, Y, Z, W}) == 4:  # Avoid duplicates/self-loops
                        motifs.append((X, Y, Z, W))

    return motifs
    # ----------------- END OF FUNCTION --------------------- #

"""## 1.2.3. Motif clustering"""

def get_motifs_clusters(G: nx.DiGraph, motifs: list, \
                        mtype: str="ffl") -> List[Set[str]]:
    """
    Analyse the subgraph created from edges belonging to motifs.

    Parameters
    ----------
    - param: G : Networkx digraph
        Graph to analyze
    - param: motifs : list
        List of motifs
    - param: mtype : str
        Motif type ("ffl" or "bf")
    - return : list
        List of weakly connected components in the motifs subgraph
    """
    # ------- IMPLEMENT HERE THE BODY OF THE FUNCTION ------- #
    motif_edges = set()

    if mtype == "ffl":
        for X, Y, Z in motifs:
            motif_edges.add((X, Y))
            motif_edges.add((X, Z))
            motif_edges.add((Y, Z))
    elif mtype == "bf":
        for X, Y, Z, W in motifs:
            motif_edges.add((X, Z))
            motif_edges.add((X, W))
            motif_edges.add((Y, Z))
            motif_edges.add((Y, W))
    else:
        raise ValueError("Unknown motif type: must be 'ffl' or 'bf'")

    # Create subgraph from motif edges
    H = nx.DiGraph()
    H.add_edges_from(motif_edges)

    # Find weakly connected components
    clusters = list(nx.weakly_connected_components(H))
    return clusters
    # ----------------- END OF FUNCTION --------------------- #

"""## 1.2.4. Comparison with Random Graph Models"""

def compare_with_random_graphs(G: nx.DiGraph, n_random: int):
    """
    Compare motif statistics of the original graph with random graphs generated by the directed configuration model.
    For each motif type (ffl and bf), prints:
        - Number of motifs
        - Number of nodes participating in motifs
        - Number of motif clusters
        - Distribution of motif cluster sizes
    Parameters
    ----------
    - param: G : Networkx digraph
        Original graph to analyze
    - param: n_random : int
        Number of random graphs to generate
    """
    # ------- IMPLEMENT HERE THE BODY OF THE FUNCTION ------- #
    def compute_motif_stats(G, motif_type="ffl"):
        if motif_type == "ffl":
            motifs = find_ffl_motifs(G)
        else:
            motifs = find_bf_motifs(G)
        node_set = set()
        for motif in motifs:
            node_set.update(motif)
        clusters = get_motifs_clusters(G, motifs, mtype=motif_type)
        cluster_sizes = [len(c) for c in clusters]
        return {
            "n_motifs": len(motifs),
            "n_nodes_in_motifs": len(node_set),
            "n_clusters": len(clusters),
            "cluster_size_dist": Counter(cluster_sizes)
        }

    def directed_configuration_model(G):
        in_deg_seq = [d for n, d in G.in_degree()]
        out_deg_seq = [d for n, d in G.out_degree()]
        random_graph = nx.directed_configuration_model(out_deg_seq, in_deg_seq, create_using=nx.DiGraph)
        # Clean up multi-edges and self-loops
        random_graph = nx.DiGraph(nx.DiGraph(random_graph).edge_subgraph(e for e in random_graph.edges if e[0] != e[1]))
        random_graph.remove_edges_from(nx.selfloop_edges(random_graph))
        return random_graph

    # Analyze original graph
    print("=== ORIGINAL GRAPH ===")
    for motif_type in ["ffl", "bf"]:
        print(f"\nMotif type: {motif_type.upper()}")
        stats = compute_motif_stats(G, motif_type)
        for key, value in stats.items():
            print(f"{key}: {value}")

    # Analyze random graphs
    print("\n=== RANDOM GRAPHS ===")
    for motif_type in ["ffl", "bf"]:
        print(f"\nMotif type: {motif_type.upper()}")
        all_stats = {
            "n_motifs": [],
            "n_nodes_in_motifs": [],
            "n_clusters": [],
            "cluster_size_dist": []
        }

        for _ in range(n_random):
            Gr = directed_configuration_model(G)
            stats = compute_motif_stats(Gr, motif_type)
            all_stats["n_motifs"].append(stats["n_motifs"])
            all_stats["n_nodes_in_motifs"].append(stats["n_nodes_in_motifs"])
            all_stats["n_clusters"].append(stats["n_clusters"])
            all_stats["cluster_size_dist"].append(stats["cluster_size_dist"])

        for stat_name in ["n_motifs", "n_nodes_in_motifs", "n_clusters"]:
            values = all_stats[stat_name]
            print(f"{stat_name} (mean ± std): {np.mean(values):.2f} ± {np.std(values):.2f}")

        # Cluster size distribution (averaged)
        total_dist = Counter()
        for dist in all_stats["cluster_size_dist"]:
            total_dist.update(dist)
        avg_dist = {k: v / n_random for k, v in total_dist.items()}
        print(f"Avg cluster size distribution: {dict(sorted(avg_dist.items()))}")
    # ----------------- END OF FUNCTION --------------------- #

"""## 1.2.5. Bi-fan overlap analysis"""

def compute_bf_overlap(bifan_list : list, TF1_locus_tag : str, \
                       TF2_locus_tag : str) -> Tuple[int, int, int]:
    """
    Compute the overlap between bi-fan motifs in which two TFs participate.
    Returns a tuple containing:
        - Number of bi-fan motifs in which the first TF participates
        - Number of bi-fan motifs in which the second TF participates
        - Number bi-fan motifs in which both TFs participate

    Parameters
    ----------
    - param: bifan_list : list
        List of all bi-fan motifs identified in a network
    - param: TF1_locus_tag: str
        Locus tag of motif 1
    - param: TF1_locus_tag: str
        Locus tag of motif 1
    - return : tuple
        Tuple containing:
            - TF1 number of BF motifs
            - TF2 number of BF motifs
            - Number of shared BF motifs
    """
    # ------- IMPLEMENT HERE THE BODY OF THE FUNCTION ------- #
    tf1_count = 0
    tf2_count = 0
    both_count = 0

    for X, Y, Z, W in bifan_list:
        tf1_in = TF1_locus_tag in (X, Y)
        tf2_in = TF2_locus_tag in (X, Y)

        if tf1_in:
            tf1_count += 1
        if tf2_in:
            tf2_count += 1
        if tf1_in and tf2_in:
            both_count += 1

    return (tf1_count, tf2_count, both_count)
    # ----------------- END OF FUNCTION --------------------- #

"""## Main"""

# for question 2
def print_cluster_distribution(clusters, label=""):
    sizes = [len(c) for c in clusters]
    dist = Counter(sizes)
    print(f"{label} cluster size distribution:")
    for size, count in sorted(dist.items()):
        print(f"  Size {size}: {count} clusters")
    print(f"  → Avg size: {sum(sizes)/len(sizes):.2f}, Max size: {max(sizes)}\n")

# for qiestion 3
def get_secondary_clusters(clusters: List[set]) -> List[set]:
    if not clusters:
        return []
    # Sort clusters by size
    clusters_sorted = sorted(clusters, key=lambda x: len(x), reverse=True)
    return clusters_sorted[1:]  # Skip the largest one
#for question 5
def analyze_arab(g: nx.DiGraph, target: str = 'b0063'):
    print(f"\n--- Analysis of {target} ---")

    # Find TFs regulating araB
    tf_list = list(g.predecessors(target))
    print(f"TFs regulating {target}: {tf_list}")

    # For each TF, check if it also regulates another TF that regulates araB (for FFL)
    ffl_candidates = []
    for tf1 in tf_list:
        for tf2 in tf_list:
            if tf1 != tf2 and g.has_edge(tf1, tf2):
                ffl_candidates.append((tf1, tf2, target))

    if ffl_candidates:
        print("FFL motifs involving araB:")
        for motif in ffl_candidates:
            print(f"  {motif[0]} → {motif[1]} → {motif[2]} and {motif[0]} → {motif[2]}")
    else:
        print("No FFL motif found involving araB.")

    return tf_list, ffl_candidates
#for Question 7
def top_outdegree_tfs(G: nx.DiGraph, top_n=3) -> List[str]:
    out_degrees = G.out_degree()
    sorted_tfs = sorted(out_degrees, key=lambda x: x[1], reverse=True)
    return [node for node, deg in sorted_tfs[:top_n]]

def compute_bf_participation(bifan_list: List[Tuple[str, str, str, str]], tf: str) -> int:
    return sum(1 for bf in bifan_list if tf in bf[:2])

def compute_bf_overlap_three(bifan_list: List[Tuple[str, str, str, str]], tf_list: List[str]):
    individual_counts = {tf: compute_bf_participation(bifan_list, tf) for tf in tf_list}
    shared_counts = {}
    for i in range(len(tf_list)):
        for j in range(i+1, len(tf_list)):
            tf1, tf2 = tf_list[i], tf_list[j]
            shared = sum(1 for bf in bifan_list if tf1 in bf[:2] and tf2 in bf[:2])
            shared_counts[(tf1, tf2)] = shared
    return individual_counts, shared_counts

if __name__ == "__main__":
    # ------- IMPLEMENT HERE THE MAIN FOR THIS SESSION ------- #

    #Question 1
    # Detect FFL and Bi-Fan motifs
    print("\nGene-level TRN:")
    ffl_gene = find_ffl_motifs(G)
    bf_gene = find_bf_motifs(G)
    print(f"FFL motifs: {len(ffl_gene)}")
    print(f"Bi-Fan motifs: {len(bf_gene)}")

    print("\nOperon-level TRN:")
    ffl_operon = find_ffl_motifs(G_operon)
    bf_operon = find_bf_motifs(G_operon)
    print(f"FFL motifs: {len(ffl_operon)}")
    print(f"Bi-Fan motifs: {len(bf_operon)}")

    #Question 2
    ffl_clusters_gene = get_motifs_clusters(G, ffl_gene, mtype="ffl")
    ffl_clusters_operon = get_motifs_clusters(G_operon, ffl_operon, mtype="ffl")
    bf_clusters_gene = get_motifs_clusters(G, bf_gene, mtype="bf")
    bf_clusters_operon = get_motifs_clusters(G_operon, bf_operon, mtype="bf")

    print_cluster_distribution(ffl_clusters_gene, label="FFL - Gene-level")
    print_cluster_distribution(ffl_clusters_operon, label="FFL - Operon-level")
    print_cluster_distribution(bf_clusters_gene, label="Bi-Fan - Gene-level")
    print_cluster_distribution(bf_clusters_operon, label="Bi-Fan - Operon-level")
    #Question 3
    # Get secondary clusters
    sec_ffl = get_secondary_clusters(ffl_clusters_gene)
    sec_bf = get_secondary_clusters(bf_clusters_gene)

    # Compare and print overlaps
    print("\n--- Secondary Cluster Overlaps (Gene-level) ---")
    for i, c1 in enumerate(sec_ffl):
        for j, c2 in enumerate(sec_bf):
            overlap = c1 & c2
            if overlap:
                print(f"FFL cluster {i+1} & BF cluster {j+1}: shared genes = {overlap}")

    #Qestion 4
    print("\n=== COMPARISON WITH RANDOM GRAPHS ===")
    print("\n--- Gene-level TRN ---")
    compare_with_random_graphs(G, n_random=5)

    print("\n--- Operon-level TRN ---")
    compare_with_random_graphs(G_operon, n_random=5)

    #Question 5
    tfs, ffls = analyze_arab(G)  # G is the gene-level graph


    #Question 7
    top_tfs = top_outdegree_tfs(G)
    print("Top 3 TFs with highest out-degree:", top_tfs)

    individual, shared = compute_bf_overlap_three(bf_gene, top_tfs)
    print("\nBi-Fan motifs per TF:")
    for tf, count in individual.items():
        print(f"{tf}: {count} motifs")

    print("\nShared bi-fans between TF pairs:")
    for pair, count in shared.items():
        print(f"{pair}: {count} shared motifs")
    # ------------------- END OF MAIN ------------------------ #

